# Back to the Feature

> ⚠️ **WARNING: This is a Proof of Concept (POC) fully generated by Claude code** ⚠️
>
> This project is **NOT production-ready** and should be considered experimental. It lacks essential production features such as:
> - Proper API authentication and authorization
> - Rate limiting and security hardening
> - Performance optimizations and caching
> - Comprehensive error handling
> - Monitoring and observability
> - Production-grade input validation and sanitization
> - Scalability considerations
>
> **Note:** While group expressions use secure JMESPath evaluation, other security aspects need implementation for production use.
>
> **Use at your own risk. Not recommended for production environments.**

A minimalist open-source feature flags management service with web interface and user system, inspired by Flipper.

## Screenshots

### Feature Flags Dashboard
<img width="1248" height="914" alt="Feature Flags Dashboard showing the main interface with flags, status badges, and management actions" src="https://github.com/user-attachments/assets/0befe4f2-f291-416d-826c-a181bdf2e9b1" />

### Flag Details and Rules Management
<img width="1240" height="1050" alt="Flag details page showing rules configuration, targeting options, and evaluation settings" src="https://github.com/user-attachments/assets/7dc8e9d8-58ee-45f2-bd64-de94a8045c1a" />

## Features

- ✅ **Feature Flag Management** : Create, edit and delete feature flags
- ✅ **Rules System** : Support for boolean, percentage and group-based rules
- ✅ **Feature Control** : Simple on/off control with percentage and group rules
- ✅ **User Groups** : Define user groups with secure JMESPath expressions
- ✅ **Web Interface** : Simple and intuitive interface with Tailwind CSS
- ✅ **REST API** : Complete API for external application integration
- ✅ **Authentication** : User system with admin/user roles
- ✅ **Kill Switch** : Instantly disable any flag
- ✅ **Secure Evaluation** : JMESPath for safe expression evaluation without code execution risks

## Installation

1. **Clone the repository**
   ```bash
   git clone <repository-url>
   cd back_to_the_feature
   ```

2. **Install dependencies**
   ```bash
   bundle install
   ```

3. **Setup the database**
   ```bash
   rails db:create
   rails db:migrate
   rails db:seed
   ```

4. **Start the server**
   ```bash
   rails server
   ```

5. **Access the application**
   - Open http://localhost:3000
   - Login with `admin` / `password`

## Usage

### Web Interface

1. **Login** : Use the default admin account or create a new account
2. **Flag Management** : Create feature flags with descriptions
3. **Add Rules** : Configure activation rules (boolean, percentage, group)
4. **Group Management** : Define user groups with logical expressions
5. **Administration** : Admins can manage users and their roles

### REST API

#### Authentication
The API uses session authentication. Login first through the web interface or implement API key authentication for production use.

#### Main Endpoints

**List flags**
```bash
GET /api/v1/flags
```

**Create a flag**
```bash
POST /api/v1/flags
Content-Type: application/json

{
  "flag": {
    "name": "new_feature",
    "description": "New feature description"
  }
}
```

**Add a rule**
```bash
POST /api/v1/flags/:flag_id/rules
Content-Type: application/json

{
  "rule": {
    "type": "percentage_of_actors",
    "value": "25"
  }
}
```

**Evaluate a flag**
```bash
GET /api/v1/evaluate/:flag_name?user_id=123&user_attributes[email]=user@company.com&user_attributes[role]=premium
```

Or via POST with JSON:
```bash
POST /api/v1/evaluate/:flag_name
Content-Type: application/json

{
  "user_id": 123,
  "user_attributes": {
    "id": 123,
    "email": "user@company.com",
    "username": "john_doe",
    "role": "premium",
    "country": "US",
    "subscription": "pro"
  }
}
```

Response:
```json
{
  "flag_name": "new_feature",
  "enabled": true,
  "rule_type": "percentage_of_actors",
  "rule_id": 42
}
```

### Flag Control

Each flag has a global **enabled/disabled** toggle that acts as a kill switch. When disabled, the flag will always return `false` regardless of any rules.

### Rule Types

1. **Percentage of Actors** : Percentage of users
   - Value: 0-100
   - Uses deterministic hashing of user ID

2. **Group** : User groups
   - References a separately defined group
   - Evaluates the group's logical expression

### Group Expressions

Groups use **JMESPath expressions** to evaluate user attributes sent by client applications. JMESPath provides a safe, standardized query language for JSON data.

```javascript
// Users with company email
ends_with(email, '@company.com')

// Admin users
starts_with(username, 'admin_')

// Premium users
role == 'premium'

// Users from specific countries
contains(['US', 'CA'], country)

// Subscription type
subscription == 'pro'

// Specific IDs
contains([1, 2, 3, 4, 5], id)

// Combined conditions
email && role == 'premium'

// Negation
role != 'basic'
```

**Security Features:**
- ✅ **Safe evaluation** - No code execution risks
- ✅ **Input validation** - Expressions are validated before saving
- ✅ **Standardized syntax** - Uses JMESPath specification
- ✅ **Error handling** - Invalid expressions fail safely

**Important:** Groups evaluate attributes provided by the client application via the API. The client application must send all attributes necessary for group evaluation.

## Architecture

### Data Models

- **User** : Users with authentication and roles
- **Flag** : Feature flags with name and description
- **Rule** : Activation rules attached to flags
- **Group** : User groups with secure JMESPath expressions
- **GroupExpressionValidator** : Validates JMESPath expressions for security

### Evaluation Service

The `FlagEvaluationService` evaluates flags with this logic:

1. **Kill switch** : If flag is globally disabled, return false immediately
2. **Rule order** : Evaluate rules in creation order
3. **First applicable rule** : First matching rule determines the result

### Security

- Session authentication with `has_secure_password`
- CSRF protection enabled
- Input data validation
- Role-based authorization
- **JMESPath expression evaluation** - Safe, standardized query language without code execution risks
- **Expression validation** - Pre-validation of group expressions before storage

## How It Works as an External Service

### Centralized Flag Management
- Single Rails instance manages all feature flags
- Multiple client applications call the API for flag evaluation
- Real-time evaluation on each API call

### Client Integration Example

```ruby
# In your e-commerce application
class DashboardController < ApplicationController
  def show
    flag_result = evaluate_feature_flag('new_dashboard', current_user)

    if flag_result['enabled']
      render 'dashboard/new_version'
    else
      render 'dashboard/old_version'
    end
  end

  private

  def evaluate_feature_flag(flag_name, user)
    response = HTTParty.post("http://your-feature-service.com/api/v1/evaluate/#{flag_name}", {
      body: {
        user_id: user.id,
        user_attributes: {
          id: user.id,
          email: user.email,
          role: user.role,
          country: user.country,
          subscription: user.subscription_type
        }
      }.to_json,
      headers: { 'Content-Type' => 'application/json' }
    })

    JSON.parse(response.body)
  end
end
```

### Evaluation Flow

1. **Client Request** : Your application sends user attributes to the API
2. **Rule Evaluation** : Service evaluates rules against user attributes
3. **Response** : Service returns flag status and evaluation context

### Benefits

- **Centralized Control** : Manage all feature flags from one place
- **Real-time Updates** : Changes take effect immediately across all applications
- **Consistent Experience** : Same user always gets same result (deterministic)
- **Kill Switch** : Instantly disable features across all applications with global flag toggle

## Testing

```bash
# Run all tests
bundle exec rspec

# Tests with documentation format
bundle exec rspec --format documentation
```

## Production Environment

1. **Environment variables**
   ```bash
   export RAILS_ENV=production
   export SECRET_KEY_BASE=<your-secret-key>
   export DATABASE_URL=<your-database-url>
   ```

2. **Compile assets**
   ```bash
   rails assets:precompile
   ```

3. **Migrate database**
   ```bash
   rails db:migrate
   ```

## Deployment with Kamal

The project is configured for deployment with Kamal:

```bash
# Initial setup
kamal setup

# Deploy
kamal deploy
```

## API Authentication for Production

For production use, implement API key authentication:

1. Generate API keys for client applications
2. Add API key validation in `Api::V1::BaseController`
3. Include API key in client requests

Example implementation:
```ruby
# In Api::V1::BaseController
before_action :authenticate_api_key!

private

def authenticate_api_key!
  api_key = request.headers['X-API-Key']
  unless valid_api_key?(api_key)
    render json: { error: 'Invalid API key' }, status: :unauthorized
  end
end
```

## Contributing

1. Fork the project
2. Create a feature branch
3. Add tests for your code
4. Ensure all tests pass
5. Create a Pull Request

## License

MIT License - see LICENSE file for details.
